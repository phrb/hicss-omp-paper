\section{Conclusions and next steps}
\label{sec:conclusions}

This paper's results reiterate that, even though \texttt{OpenMP} can be easy to use, programmers still need to know the details about parallel computing architectures and platforms. Teaching and learning the fundamental concepts about parallel programming is, and will continue to be, necessary to write accurate and high-performance code.

The experimental results show that although Internet tutorials transmit the idea of ease-of-use of the compilation directives approach, the core concepts of parallelism are required to write good parallel programs. Knowing the underlying platform and architectural details, and what effects are caused by directives and their interactions is also required.

Using \texttt{OpenMP} for trivial programs is easy, but for more advanced applications it is necessary to know how to correctly use locks and barriers, avoid deadlocks, and distribute the work evenly between threads. The programmer also has to be cautious when scheduling and accessing memory. To do all this correctly it is necessary to learn the fundamental concepts underlying parallel programming.

The main goal of parallel programming is writing programs that are efficient, portable and correct, leveraging contemporary hardware platforms~\cite{Asanovic2009}. These goals are still hard to reach even when using high-level approaches such as \texttt{OpenMP}.

It is important to teach Computer Science students how to program parallel applications from the beginning. Instead of teaching sequential programming first and parallel programming much later in the graduation course, Computer Science courses should start with \texttt{OpenMP} or other high-level tools, but not before providing solid fundamentals in parallel computing.

Considering the students' answers, a positive outcome of this experiment is that the students have learned that they should not rely on copying code from the Internet, because they can contain errors. Students also learned that they should test their code thoroughly, as errors in parallel programs are not easily detectable.

Future work will repeat the experiment in other instances of the graduate course, improving the experiment data set. Using a more systematic approach, future work will look for possible errors in more tutorials available on the Internet, and explore the difficulties faced by beginner and expert developers of parallel applications.

Finally, considering the results presented in this paper and the fact that even those who are teaching make mistakes in their tutorials and classes, more attention has to be devoted to teaching parallel and concurrent programming, its techniques, concepts and tools.