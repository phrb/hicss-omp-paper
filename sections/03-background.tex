\section{Background}
\label{sec:background}

Different approaches have been proposed to study the selection of the best
level of abstraction for teaching Parallel and Distributed programming courses.
Falcao~\cite{6565518} argues that introducing a high-level parallel programming
interface such as \textit{OpenMP} in the beginning of an undergraduate computer
science course would cause a small overhead and benefit the rest of the course.
Foley \textit{et al.}~\cite{FOLEY2017138} support the introduction of practical
learning experiences along an undergraduate course, of increasing depth as the
course progresses. They introduce OnRamp, a web application to help students
learn to write parallel code starting with practical and moving to conceptual
experiences.  Pllana \textit{et al.}~\cite{Pllana:2009} adopt a Model Driven
Development approach to develop parallel solutions using Parallel Building
Blocks. They introduce a programming environment that transforms these
high-level models in source code. The tool's goal is to hide from the students
the complexity of writing parallel code.

The approaches mentioned so far introduce tools for parallel programming before
the related concepts.  Other approaches instead consider learning software
tools as just one of the objectives of the course, and argue that their
introduction should come after the introduction of concepts of Parallel and
Distributed Computing.

In previous work~\cite{goncalves:OpenMPNotEasy} we show that teaching the
concepts of parallel programming first instead of high-level parallel
programming APIs is important, especially because the available resources and
tutorials for these APIs may contain difficult to find errors.  We listed
several sources of tutorials and hands-on materials obtained in the internet in
which undergraduate students were able to point parallel correctness
errors~\cite{SuB:2005:CMO:1892830.1892863}.

SÃ¼\ss{} and Leopold~\cite{Leopold:userOpenMP} discuss the inability to express
all parallel solutions in tools such as \textit{OpenMP}. They used a sorting
algorithm to show that it is easy to find patterns that are difficult to
implement in \textit{OpenMP}, but can be easily implemented in lower-level
programming interfaces, such as POSIX Threads.

Adams~\cite{ADAMS201731} presented a set of patterns implemented using
\textit{Pthreads} that can help students understand aspects of parallel
programming that would be difficult to grasp using only \textit{OpenMP}
examples. His catalog also contained patterns implemented in \textit{OpenMP}.

In this paper we present data that supports the importance of composing a
curriculum for Parallel and Distributed Computing courses using low-level
programming interfaces, such as \textit{Pthreads}, as well as high-level
interfaces, such as \textit{OpenMP}.
